\chapter{Tackling System Complexity}

\section{Component Model}

An effort to describe the system structure in a well-defined and scalable way will now be made. The core building block is the component, which will be subsequently defined. To better illustrate our approach, the example of a 1-axis digital MEMS gyroscope will be presented alongside the definition.

Initially, the notion of the service will be introduced. A service is a 6-tuple of the form:

\quad <consumed variables, produced variables, procedure, request, activation condition, resources>

This model describes the service as a process which uses \textit{consumed variables} upon \textit{request} according to a \textit{procedure} in order to return \textit{produced variables}. In order for the service to be carried out \textit{resources} are used up and an \textit{activation condition} must hold true.

Thus, using set theory for every mentioned quantity, we can define a set of services provided by a component k as:

\textbf{Definition: Service}
\begin{align*}
S(k) &= \left\{s_i(k),i\in I_s(k)\right\} \\
s_i(k) &= \left\{cons_i(k),prod_i(k),proc_i(k),rqst_i(k),active_i(k),res_i(k)\right\}
\end{align*}

The set $I_s(k)$ contains the service indices which are applicable to the component k. The same holds for the sets $cons(k),prod(k),proc(k),active(k),res(k)$.

In the case of the MEMS accelerometer with the component index 1, we can define:
\begin{align*}
I_s(1) &= \left\{1,2\right\} \\
cons(1) &= \left\{\text{angular rate }\omega, \text{temperature }K, \text{measurement noise }w, \text{initial angle input }\theta_{0i}\right\} \\
prod(1) &= \left\{\text{measured angular rate }\omega_m, \text{measured angle }\theta_m\right\} \\
proc(1) &= \left\{ \omega_m = \omega + c_1K + w, \theta_m = \theta_0 + \int\omega_m, \theta_0 = \theta_{0i}\right\} \\
rqst(1) &= \left\{ \text{I2C command}\right\} \\
active(1) &= \left\{ \text{Power supply present}\right\} \\
resources(1) &= \left\{ \text{current consumption rate}, \text{gyroscope unit}, \text{I2C channel}\right\} \\
S(1) &= \left\{s_1(k),s_2(k)\right\}
\end{align*}
Where service $s_1(1)$ is the initial sensor angle specification and $s_2(1)$ is the measurement of angular rate and angle.

\textbf{Definition: Use Mode}
We define a set of use-modes
\begin{align*}
M(k) &= \left\{m_i(k), i\in I_m(k)\right\} \\
\end{align*}
where $m_i(k)$ is the set of indices of the available component k services during the use mode i and $I_m(k)$ is the set of indices of available use modes for the component k. The applicability of services during a use mode is a designer choice.
In our example we have two use modes:
\begin{align*}
m_1(1) &= \left\{s_1(1)\right\} \quad \text{calibration mode}\\
m_2(1) &= \left\{s_2(1)\right\} \quad \text{operational mode}
\end{align*}

\textbf{Definition: Component Model}
We are now finally able to define a component as the aggregation:
\begin{align*}
\text{<component k>} &\equiv \text{<state transition graph }G(M(k),\tau(k),m^0(k))> \\
<M(k)> & \\
<\tau(k)> & \\
<m^0(k)> & \\
<m_i(k)> & \\
<s_i(k)> & \\
\end{align*}

\section{Structural Model}

Given the component descriptions we have set up and their interconnections, we can "translate" the component behavioural model onto a qualitative model for structural analysis. The qualitative model retains data only about the information flow and the component interconnections. It is essentially a directional graph which visualizes the evolution of the variables from the known system inputs towards the also known system outputs, via the unknown system internal variables and states.

A vital definition towards this goal is that of the \textit{constraint}. A constraint is a relation between two system variables, which expresses a physical model, a component model or a control law. In essence, the sum of the system constraints constitutes the full set of equations, either algebraic or differential, which make up our system.

Based on the previous component definition, the system constraints are the union of the component procedures
\begin{align*}
\mathcal{C } &= \bigcup proc(k)
\end{align*}

while all the variables involved in $\mathcal{C}$ constitute the variable set $\mathcal{Z}$.

Variables whose values are known (inputs, measurements etc) belong to the known variables set $\mathcal{K}$, whereas the rest of the variables belong to the unknown variables set $\mathcal{X}$. It holds that $\mathcal{Z = K \cup X}$.

We define a bi-partite graph ($\mathcal{C, Z, A}$), with vertices $\mathcal{C, Z}$ and edges $\mathcal{A}$ linking constraints with their corresponding variables.
It is meaningful to define directionality in the graph, to reflect the fact that a single constraint cannot be solved for any of its variables. Indeed, from the simple differential equation $x_2 = \dot{x_1}$, we cannot extract the values of $x_1$, since that would require the additional initial condition, which is not given.

An important segmentation of $\mathcal{C}$ in regard to $\mathcal{Z}$ is splitting it to:\\
$\mathcal{C_K}$, which contains the restrictions which refer only to known variables\\
$\mathcal{C_X}=\mathcal{C-C}_K$

To showcase this approach, let us consider another example, a spring-mass system with position measuring.
\begin{alignat*}{2}
c_1: &\quad& \dot{x} &= \frac{d}{dt}x \\
c_2: &\quad& v &= \dot{x} \\
c_3: &\quad& \dot{v} &= \frac{d}{dt}v\\
c_4: &\quad& \dot{v} &= \frac{K}{m}x\\
m_1: &\quad& x_m &= x\\
\end{alignat*}

The constraints set is $\mathcal{C}=\left\{c_1, c_2, c_3, c_4, m_1\right\}$\\
The known variables set is $\mathcal{K}=\left\{x_m\right\}$\\
The unknown variables set is $\mathcal{X}= \left\{x, \dot{x}, v, \dot{v}\right\}$\\
The resulting graph is: \\
\input{graph}

Naturally, this graph could be represented as an incidence matrix $D$, where $$
d_{ij} = \left\{\begin{array} {rl}
0 \quad &\text{if }(z_i, c_i)\in\mathcal{A} \\
1 \quad &\text{if }(z_i, c_i)\notin\mathcal{A} 
\end{array}\right.
$$
We could extend this definition to include the graph directionality if we wanted to, by setting the vertices of $\mathcal{A}$ to not be bi-directional but rather two separate vertices. This would make the matrix D non-symmetrical.

Having set up the necessary mathematical tools (graphs and adjacency matrices) to explore the system structure, we are able to gain much more insight on our system. For example, we can use the existence of paths connecting nodes to explore whether one variable $ x_1$of our system is related to another $x_2$, in other words, if $\frac{\partial}{\partial x_1}x_2 \neq 0$.
Moreover, we can discuss about whether an internal variable is \textbf{observable}, by finding connected paths originating from it and reaching known variables. Finally, we can even find if variables of our system are \textbf{controllable}, by looking for connected paths to input variables. This will be especially useful in cases where we want to design reconfigurable controllers for our system.