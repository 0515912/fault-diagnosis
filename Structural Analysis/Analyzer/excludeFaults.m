function [ faults_excluded ] = excludeFaults( FSStruct, triggered_residuals )
%EXCLUDEFAULTS Find which faults have not manifested
%   Find which faults have not manifested, based on the triggered residuals array. The Exoneration Assumption is made
% INPUTS:
% FSSStruct     : Fault Signature structure, as returned by generateFSM()
% triggered_residuals: Triggered residuals binary array, as generated by thresholdResiduals()
% OUPTUTS:
% faults_excluded: An array with the ids of the faults which cannot have occurred

faults_excluded = cell(1,size(triggered_residuals,2)); % Initialize the output array
FSM = FSStruct.FSM; % Get the Fault Signature Matrix
valid_matchings_mask = FSStruct.valid_matchings_mask; % Get the mask which says which residuals are valid
fault_ids = FSStruct.fault_ids; % Get the involved fault IDs

% For each time sample
for i=1:length(faults_excluded)
    actual_fault_signature = triggered_residuals(:,i); % This is the fault signature of this time sample
    
    non_explaining_faults = [];
    % For each residual
    for j=1:length(actual_fault_signature)
        
        % Check if it was actually implemented
        if ~valid_matchings_mask(j)
            continue;
        end
        
        % If this residual did not trigger
        if ~actual_fault_signature(j)
            related_fault_mask = FSM(j,:); % This is the Fault Signature of this residual
            related_fault_ids = fault_ids(logical(related_fault_mask)); % These are the faults to which this residual is sensitive
            % Since this residual did not trigger, the faults to which it is sensitive cannot have occurred.
            % Add them to the non-explainin-faults set.
            non_explaining_faults = union(non_explaining_faults, related_fault_ids); 
        end
    end
    faults_excluded{i} = non_explaining_faults;
    
    % Also exclude non-detectable faults
    faults_excluded{i} = union(faults_excluded{i}, FSStruct.non_detectable_fault_ids);
end


end

