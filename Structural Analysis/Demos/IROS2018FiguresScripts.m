%% NOTE
%This file contains edited versions of various plotting functions which
% are tailored to the IROS2018 submission, which uses the g033 MAVLink
% model

%WARNING:  Run the testing.m script first

%% Generate the fault occurence plot

% Required:
% SA_results
% candidate_fault_ids
interval = interval_of_interest-1; % interval_of_interest-1

% Get the fault_ids array
ids_flattened = [];
for i=1:length(candidate_fault_ids)
    ids_flattened = [ids_flattened candidate_fault_ids{i}];
end
ids_flattened = unique(ids_flattened);

% Remove any faults you don't want to plot
unwanted_fault_ids = SA_results.gi.getVarIdByAlias({'fseq58', 'fseq55','fseq56','fseq57'});
ids_flattened = setdiff(ids_flattened, unwanted_fault_ids);

% Get the expressions for use as labels
fault_equations = SA_results.gi.getEquations(ids_flattened);
% expressions_flattened = SA_results.gi.getExpressionById(fault_equations);
expressions_flattened = {...
    '24/lon',...
    '24/alt',...
    '30/roll',...
    '30/pitch',...
    '30/rollspeed',...
    '30/pitchspeed',...
    '30/yawspeed',...
    '32/p_d',...
    '32/v_d',...
    '33/lon',...
    '33/alt',...
    '33/v_z',...
    '62/nav_roll',...
    '62/nav_pitch',...
    '62/error_alt',...
    '62/aspd_error',...
    '62/error_xtrack',...
    '74/airspeed',...
    '74/alt',...
    '116/xgyro',...
    '116/ygyro',...
    '116/zgyro',...
    '163/error_rp',...
    '163/error_yaw',...
    '168/dir',...
    '168/speed',...
    '178/roll',...
    '178/pitch',...
    '182/roll',...
    '182/pitch',...
    '182/alt',...
    '182/lat',...
    '182/lng'...
    };

% Setup subsystem colors
clr_yellow = [1 1 0];
clr_red = [1 0 0];
clr_blue = [0 0 1];
clr_green = [0 1 0];
clr_black = [0 0 0];
clr_sensors = clr_yellow;
clr_autopilot = clr_red;
clr_navigation = clr_blue;
clr_default = clr_green;
clr_os = clr_black;

% Draw an interval graph to inpspect the timestamp intervals
thickness = 1;
X_arg = [];
Y_arg = [];
C_arg = [];
% Iterate within the interval
counter = 1;
for i=1:length(candidate_fault_ids)
    for j=1:length(candidate_fault_ids{i})
        id = candidate_fault_ids{i}(j);
        %         expression = SA.gi.getExpression(ids);
        id_index = find(ismember(ids_flattened,id));
        if isempty(id_index)
            continue;
        end
        
        X_arg(1:2,counter) = interval(i);
        X_arg(3:4,counter) = interval(i)+1;
        Y_arg([1 4],counter) = id_index;
        Y_arg([2 3],counter) = id_index-thickness;
        
        % Pick the fault color
        equ_id = SA_results.gi.getEquations(id);
        subsystem = SA_results.gi.getSubsystems(equ_id);
        if isempty(subsystem{1})
            C_arg(counter, 1, :) = clr_default;
        else
            
            switch subsystem{1}
                case 'autopilot'
                    C_arg(counter, 1, :) = clr_autopilot;
                case 'sensors'
                    C_arg(counter, 1, :) = clr_sensors;
                case 'navigation'
                    C_arg(counter, 1, :) = clr_navigation;
                case 'os'
                    C_arg(counter, 1, :) = clr_os;
                otherwise
                    error('Unknown subsystem %s met',subsystem{1});
            end
        end
        counter = counter + 1;
    end
end

h2 = figure();
patch(X_arg,Y_arg,C_arg);
xlabel('Time (s)');
ylabel('Message ID/field');
xlim([interval(1) interval(end)+1])
yticks(linspace(thickness/2, length(expressions_flattened)+thickness/2-1,length(expressions_flattened)));
yticklabels(expressions_flattened);
set(gca,'TickLabelInterpreter','none');
ylim([0, length(expressions_flattened)]);

fh = gcf;
fh.Position = [2692 158 567 765];

grid on

%% Airspeed plots

% Extract the residual

fault_id = SA_results.gi.getVarIdByAlias('fseq43');
residual_indices = findRelatedResiduals(SA_results, FSStruct, fault_id);
time_series = interval_of_interest-1;
residual_series = RE_results.residuals(residual_indices,interval_of_interest);
assert(all(size(residual_series)==size(time_series)));
csvwrite('airspeed-residual.csv',[time_series; residual_series]');
airspeed_series = data_resampled.airspeed_vfr_hud(interval_of_interest);
csvwrite('airspeed.csv',[time_series; airspeed_series]');

%% R-P-Alt plots

time_series = interval_of_interest-1;
roll_series = data_resampled.roll_attitude(interval_of_interest);
pitch_series = data_resampled.pitch_attitude(interval_of_interest);
alt_series = data_resampled.alt_vfr_hud(interval_of_interest)-1031.8;
csvwrite('/home/george/Documents/paper 6/paper/figures/data/roll.csv', [time_series; rad2deg(roll_series)]');
csvwrite('/home/george/Documents/paper 6/paper/figures/data/pitch.csv', [time_series; rad2deg(pitch_series)]');
csvwrite('/home/george/Documents/paper 6/paper/figures/data/alt.csv', [time_series; alt_series]');

%% Isolation matrix

% Find which faults you don't want to plot
unwanted_fault_ids = SA_results.gi.getVarIdByAlias({'fseq5', 'fseq13'});

IMStruct_iros = generateIM(SA_results.gi, FSMStruct, unwanted_fault_ids);
plotIM(IMStruct_iros);

numFaults = length(IMStruct_iros.fault_ids);

% Permute the IM
[p,q] = dmperm(IMStruct_iros.IM);   

spy(IMStruct_iros.IM(p,q))

set(gca,'XTick', 1:numFaults);
set(gca,'YTick', 1:numFaults);

% Print the related fault equations
% disp(SA_results.gi.getExpressionById(SA_results.gi.getEquations(IMStruct_iros.fault_ids)));

fault_labels = {...
    '1/load', ...
    '1/voltage_battery', ...
    '1/current_battery', ...
    '1/drop_rate_comm', ...
    '24/lat', ...
    '24lon', ...
    '24/alt', ...
    '24/eph', ...
    '24/epv', ...
    '24/vel', ...
    '24/cog', ...
    '29/press_diff', ...
    '29/temperature', ...
    '30/roll', ...
    '30/pitch', ...
    '30/yaw', ...
    '30/rollspeed', ...
    '30/pitchspeed', ...
    '30/yawspeed', ...
    '32/x', ...
    '32/y', ...
    '32/z', ...
    '32/vx', ...
    '32/vy', ...
    '32/vz', ...
    '33/lat', ...
    '33/lon', ...
    '33/alt', ...
    '33/relative_alt', ...
    '33/vx', ...
    '33/vy', ...
    '33/vz', ...
    '33/hdg', ...
    '62/nav_roll', ...
    '62/nav_pitch', ...
    '62/nav_bearing', ...
    '62/alt_error', ...
    '62/aspd_error', ...
    '62/xtrack_error', ...
    '74/airspeed', ...
    '74/groundspeed', ...
    '74/heading', ...
    '74/alt', ...
    '74/climb', ...
    '116/xgyro', ...
    '116/ygyro', ...
    '116/zgyro', ...
    '116/xmag', ...
    '116/ymag', ...
    '116/zmag', ...
    '125/vcc', ...
    '125/vservo', ...
    '152/freemem', ...
    '163/error_rp', ...
    '163/error_yaw', ...
    '165/vcc', ...
    '168/direction', ...
    '168/speed', ...
    '174/ratio', ...
    '178/roll', ...
    '178/pitch', ...
    '178/yaw', ...
    '182/roll', ...
    '182/pitch', ...
    '182/yaw', ...
    '182/altitude', ...
    '182/lat', ...
    '182/lng', ...
    '241/vibration_x', ...
    '241/vibration_y', ...
    '241/vibration_z' 
    };


set(gca,'TickLabelInterpreter','none');
set(gca,'XTickLabel', fault_labels(p));
set(gca,'YTickLabel',fault_labels(p));
% set(gca,'XTickLabel', {});
% set(gca,'YTickLabel',{});
xtickangle(90);

xlabel('')

% title('');
title('Isolability Matrix');

%% Generate Fault Grid frames

interval = interval_of_interest-1;

% For each second
for cnt1=1:length(candidate_fault_ids)
    % Mask the sample instances
    sample_mask = zeros(size(interval));
    sample_mask(1:cnt1) = 1;
    % Generate the plot
    
    % Get the fault_ids array
    ids_flattened = [];
    for i=1:length(candidate_fault_ids)
        ids_flattened = [ids_flattened candidate_fault_ids{i}];
    end
    ids_flattened = unique(ids_flattened);
    
    % Remove any faults you don't want to plot
    unwanted_fault_ids = SA_results.gi.getVarIdByAlias({'fseq58', 'fseq55','fseq56','fseq57'});
    ids_flattened = setdiff(ids_flattened, unwanted_fault_ids);
    
    % Get the expressions for use as labels
    fault_equations = SA_results.gi.getEquations(ids_flattened);
    % expressions_flattened = SA_results.gi.getExpressionById(fault_equations);
    expressions_flattened = {...
        '24/lon',...
        '24/alt',...
        '30/roll',...
        '30/pitch',...
        '30/rollspeed',...
        '30/pitchspeed',...
        '30/yawspeed',...
        '32/p_d',...
        '32/v_d',...
        '33/lon',...
        '33/alt',...
        '33/v_z',...
        '62/nav_roll',...
        '62/nav_pitch',...
        '62/error_alt',...
        '62/aspd_error',...
        '62/error_xtrack',...
        '74/airspeed',...
        '74/alt',...
        '116/xgyro',...
        '116/ygyro',...
        '116/zgyro',...
        '163/error_rp',...
        '163/error_yaw',...
        '168/dir',...
        '168/speed',...
        '178/roll',...
        '178/pitch',...
        '182/roll',...
        '182/pitch',...
        '182/alt',...
        '182/lat',...
        '182/lng'...
        };
    
    % Setup subsystem colors
    clr_yellow = [1 1 0];
    clr_red = [1 0 0];
    clr_blue = [0 0 1];
    clr_green = [0 1 0];
    clr_black = [0 0 0];
    clr_sensors = clr_yellow;
    clr_autopilot = clr_red;
    clr_navigation = clr_blue;
    clr_default = clr_green;
    clr_os = clr_black;
    
    % Draw an interval graph to inpspect the timestamp intervals
    thickness = 1;
    X_arg = [];
    Y_arg = [];
    C_arg = [];
    % Iterate within the interval
    counter = 1;
    for i=1:length(candidate_fault_ids)
        if ~sample_mask(i)
            continue;
        end
        for j=1:length(candidate_fault_ids{i})
            id = candidate_fault_ids{i}(j);
            %         expression = SA.gi.getExpression(ids);
            id_index = find(ismember(ids_flattened,id));
            if isempty(id_index)
                continue;
            end
            
            X_arg(1:2,counter) = interval(i);
            X_arg(3:4,counter) = interval(i)+1;
            Y_arg([1 4],counter) = id_index;
            Y_arg([2 3],counter) = id_index-thickness;
            
            % Pick the fault color
            equ_id = SA_results.gi.getEquations(id);
            subsystem = SA_results.gi.getSubsystems(equ_id);
            if isempty(subsystem{1})
                C_arg(counter, 1, :) = clr_default;
            else
                
                switch subsystem{1}
                    case 'autopilot'
                        C_arg(counter, 1, :) = clr_autopilot;
                    case 'sensors'
                        C_arg(counter, 1, :) = clr_sensors;
                    case 'navigation'
                        C_arg(counter, 1, :) = clr_navigation;
                    case 'os'
                        C_arg(counter, 1, :) = clr_os;
                    otherwise
                        error('Unknown subsystem %s met',subsystem{1});
                end
            end
            counter = counter + 1;
        end
    end
    
    h2 = figure();
    patch(X_arg,Y_arg,C_arg);
    xlabel('Time (s)');
    ylabel('Message ID/field');
    xlim([interval(1) interval(end)+1])
    yticks(linspace(thickness/2, length(expressions_flattened)+thickness/2-1,length(expressions_flattened)));
    yticklabels(expressions_flattened);
    set(gca,'TickLabelInterpreter','none');
    ylim([0 length(expressions_flattened)+thickness/2]);
    
    fh = gcf;
    fh.Position = [2692 158 567 765];
    
    grid on
    
    pause();
    % Save the frame
    saveas(gcf, sprintf('Plotter/IROSFigures/fg%03d.png',cnt1));
    close(h2);
    
    
end